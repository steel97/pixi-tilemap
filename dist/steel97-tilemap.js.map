{"version":3,"file":"steel97-tilemap.js","sources":["../src/settings.ts","../src/TilemapGeometry.ts","../src/TilemapPipe.ts","../src/TileTextureArray.ts","../src/gl_tilemap.ts","../src/gpu_tilemap.ts","../src/Tilemap.ts","../src/CompositeTilemap.ts","../src/index.ts"],"sourcesContent":["import { SCALE_MODE } from 'pixi.js';\r\n\r\n/**\r\n * These are additional @pixi/tilemap options.\r\n *\r\n * This settings should not be changed after the renderer has initialized; otherwise, the behavior\r\n * is undefined.\r\n */\r\nexport const settings = {\r\n    /** The default number of textures per tilemap in a tilemap composite. */\r\n    TEXTURES_PER_TILEMAP: 16,\r\n\r\n    /** The scaling mode of the combined texture tiling. */\r\n    TEXTILE_SCALE_MODE: 'linear' as SCALE_MODE,\r\n\r\n    /** This will enable 32-bit index buffers. It's useful when you have more than 16K tiles. */\r\n    use32bitIndex: false,\r\n};\r\n\r\n// @deprecated\r\nexport const Constant = settings;\r\n","import { Buffer, BufferUsage, Geometry } from 'pixi.js';\r\n\r\n// For some reason, ESLint goes mad with indentation in this file ^&^\r\n/* eslint-disable no-mixed-spaces-and-tabs, indent */\r\n\r\nexport class TilemapGeometry extends Geometry\r\n{\r\n    static vertSize = 13;\r\n    static vertPerQuad = 4;\r\n    static stride = this.vertSize * 4;\r\n    lastTimeAccess = 0;\r\n\r\n    vertSize = TilemapGeometry.vertSize;\r\n    vertPerQuad = TilemapGeometry.vertPerQuad;\r\n    stride = TilemapGeometry.stride;\r\n\r\n    constructor(indexBuffer: Buffer)\r\n    {\r\n        const buf = new Buffer({\r\n            data: new Float32Array(2),\r\n            label: 'tilemap-buffer',\r\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\r\n            shrinkToFit: false,\r\n        });\r\n\r\n        const stride = TilemapGeometry.stride;\r\n\r\n        // TODO: why location is like that in webgl? ascending?\r\n\r\n\t    super({\r\n            indexBuffer,\r\n            attributes: {\r\n                aVertexPosition: {\r\n                    buffer: buf,\r\n                    format: 'float32x2',\r\n                    stride,\r\n                    offset: 0,\r\n                    // location: 6,\r\n                },\r\n                aTextureCoord: {\r\n                    buffer: buf,\r\n                    format: 'float32x2',\r\n                    stride,\r\n                    offset: 2 * 4,\r\n                    // location: 4,\r\n                },\r\n                aFrame: {\r\n                    buffer: buf,\r\n                    format: 'float32x4',\r\n                    stride,\r\n                    offset: 4 * 4,\r\n                    // location: 3,\r\n                },\r\n                aAnim: {\r\n                    buffer: buf,\r\n                    format: 'float32x2',\r\n                    stride,\r\n                    offset: 8 * 4,\r\n                    // location: 1,\r\n                },\r\n                aTextureId: {\r\n                    buffer: buf,\r\n                    format: 'sint32',\r\n                    stride,\r\n                    offset: 10 * 4,\r\n                    // location: 5\r\n                },\r\n                aAnimDivisor: {\r\n                    buffer: buf,\r\n                    format: 'float32',\r\n                    stride,\r\n                    offset: 11 * 4,\r\n                    // location: 2\r\n                },\r\n                aAlpha: {\r\n                    buffer: buf,\r\n                    format: 'float32',\r\n                    stride,\r\n                    offset: 12 * 4,\r\n                    // location: 0\r\n                }\r\n            },\r\n        });\r\n\r\n        this.buf = buf;\r\n    }\r\n\r\n    buf: Buffer;\r\n}\r\n","import {\r\n    Buffer,\r\n    BufferUsage, ExtensionType, GlobalUniformGroup,\r\n    IndexBufferArray, Instruction, InstructionPipe, InstructionSet, Matrix, Renderer,\r\n    RenderPipe, UniformGroup\r\n} from 'pixi.js';\r\nimport { CompositeTilemap } from './CompositeTilemap';\r\nimport { settings } from './settings';\r\nimport { TilemapGeometry } from './TilemapGeometry';\r\n\r\nimport type { Tilemap } from './Tilemap';\r\n\r\n// For some reason, ESLint goes mad with indentation in this file ^&^\r\n/* eslint-disable no-mixed-spaces-and-tabs, indent */\r\n\r\nexport abstract class TilemapAdaptor\r\n{\r\n    abstract init(): void;\r\n    abstract execute(meshPipe: TilemapPipe, mesh: Tilemap): void;\r\n    abstract destroy(): void;\r\n\r\n    public pipe_uniforms = new UniformGroup({\r\n        u_proj_trans: { value: new Matrix(), type: 'mat3x3<f32>' },\r\n        u_anim_frame: { value: new Float32Array(2), type: 'vec2<f32>' },\r\n    });\r\n}\r\n\r\nexport interface TilemapInstruction extends Instruction\r\n{\r\n    renderPipeId: 'tilemap';\r\n    tilemap: Tilemap;\r\n}\r\n\r\n/**\r\n * Rendering helper pipeline for tilemaps. This plugin is registered automatically.\r\n */\r\nexport class TilemapPipe implements RenderPipe<Tilemap>, InstructionPipe<TilemapInstruction>\r\n{\r\n    public static extension = {\r\n        type: [\r\n            ExtensionType.WebGLPipes,\r\n            ExtensionType.WebGPUPipes,\r\n        ],\r\n        name: 'tilemap',\r\n    } as const;\r\n    /** The managing renderer */\r\n    public readonly renderer: Renderer;\r\n\r\n    /** The tile animation frame */\r\n    public tileAnim = [0, 0];\r\n\r\n    private ibLen = 0;// index buffer length\r\n\r\n    /** The index buffer for the tilemaps to share. */\r\n    private indexBuffer: Buffer = null;\r\n\r\n    /** The shader used to render tilemaps. */\r\n    private shader: TilemapGeometry;\r\n\r\n    private adaptor: TilemapAdaptor;\r\n\r\n    constructor(renderer: Renderer, adaptor: TilemapAdaptor)\r\n    {\r\n        this.renderer = renderer;\r\n        this.adaptor = adaptor;\r\n\r\n        this.adaptor.init();\r\n\r\n\t    this.indexBuffer = new Buffer({\r\n            data: new Uint16Array([0, 1, 2, 0, 2, 3]),\r\n            label: 'index-tilemap-buffer',\r\n            usage: BufferUsage.INDEX | BufferUsage.COPY_DST,\r\n        });\r\n\t    this.checkIndexBuffer(2000);\r\n    }\r\n\r\n    start(): void\r\n    {\r\n\t    // sorry, nothing\r\n    }\r\n\r\n    /**\r\n\t * @internal\r\n\t * @ignore\r\n\t */\r\n    createVb(): TilemapGeometry\r\n    {\r\n\t    const geom = new TilemapGeometry(this.indexBuffer);\r\n\r\n        geom.lastTimeAccess = Date.now();\r\n\r\n\t    return geom;\r\n    }\r\n\r\n    /** @return The {@link TilemapGeometry} shader that this rendering pipeline is using. */\r\n    getShader(): TilemapGeometry { return this.shader; }\r\n\r\n    destroy(): void\r\n    {\r\n\t    // this.rectShader.destroy();\r\n\t    this.shader = null;\r\n    }\r\n\r\n    // eslint-disable-next-line no-unused-vars\r\n    public checkIndexBuffer(size: number): void\r\n    {\r\n\t    const totalIndices = size * 6;\r\n\r\n\t    if (totalIndices <= this.ibLen)\r\n\t    {\r\n\t        return;\r\n\t    }\r\n\r\n\t    let len = totalIndices;\r\n\r\n\t    while (len < totalIndices)\r\n\t    {\r\n\t        len <<= 1;\r\n\t    }\r\n\r\n\t    this.ibLen = totalIndices;\r\n\t    this.indexBuffer.data = createIndicesForQuads(size,\r\n\t        settings.use32bitIndex ? new Uint32Array(totalIndices) : new Uint16Array(totalIndices));\r\n    }\r\n\r\n    destroyRenderable(_renderable: Tilemap): void\r\n    {\r\n        _renderable.vb.destroy(true);\r\n        _renderable.vb = null;\r\n    }\r\n\r\n    addRenderable(tilemap: Tilemap, instructionSet: InstructionSet | undefined): void\r\n    {\r\n        const batcher = this.renderer.renderPipes.batch;\r\n\r\n        tilemap.updateBuffer(this);\r\n        tilemap.checkValid();\r\n        tilemap.getTileset().update();\r\n\r\n        if (tilemap.is_valid)\r\n        {\r\n            batcher.break(instructionSet);\r\n            instructionSet.add(tilemap._instruction);\r\n        }\r\n    }\r\n\r\n    updateRenderable(tilemap: Tilemap, _instructionSet?: InstructionSet | undefined): void\r\n    {\r\n        tilemap.updateBuffer(this);\r\n        tilemap.getTileset().update();\r\n    }\r\n\r\n    validateRenderable(renderable: Tilemap): boolean\r\n    {\r\n        return renderable.checkValid();\r\n    }\r\n\r\n    public execute({ tilemap }: TilemapInstruction)\r\n    {\r\n        if (!tilemap.isRenderable) return;\r\n\r\n        tilemap.state.blendMode = tilemap.groupBlendMode;\r\n\r\n        const { pipe_uniforms } = this.adaptor;\r\n\r\n        const u_proj_trans = pipe_uniforms.uniforms.u_proj_trans;\r\n        const u_global = ((this.renderer.globalUniforms as any)._activeUniforms.at(-1) as GlobalUniformGroup).uniforms;\r\n        let anim_frame = this.tileAnim;\r\n        const { u_anim_frame } = pipe_uniforms.uniforms;\r\n\r\n        u_global.uProjectionMatrix.copyTo(u_proj_trans).append(u_global.uWorldTransformMatrix)\r\n            .append(tilemap.worldTransform);\r\n        if (tilemap.compositeParent)\r\n        {\r\n            anim_frame = (tilemap.parent as CompositeTilemap).tileAnim || anim_frame;\r\n        }\r\n        u_anim_frame[0] = anim_frame[0];\r\n        u_anim_frame[1] = anim_frame[1];\r\n\r\n        pipe_uniforms.update();\r\n\r\n        this.adaptor.execute(this, tilemap);\r\n    }\r\n}\r\n\r\nfunction createIndicesForQuads(\r\n    size: number,\r\n    outBuffer: IndexBufferArray\r\n): IndexBufferArray\r\n{\r\n    // the total number of indices in our array, there are 6 points per quad.\r\n    const totalIndices = size * 6;\r\n\r\n    if (outBuffer.length !== totalIndices)\r\n    {\r\n        throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);\r\n    }\r\n\r\n    // fill the indices with the quads to draw\r\n    for (let i = 0, j = 0; i < totalIndices; i += 6, j += 4)\r\n    {\r\n        outBuffer[i + 0] = j + 0;\r\n        outBuffer[i + 1] = j + 1;\r\n        outBuffer[i + 2] = j + 2;\r\n        outBuffer[i + 3] = j + 0;\r\n        outBuffer[i + 4] = j + 2;\r\n        outBuffer[i + 5] = j + 3;\r\n    }\r\n\r\n    return outBuffer;\r\n}\r\n","import { BindGroup, Buffer, BufferUsage, Texture, TextureSource, UniformGroup } from 'pixi.js';\r\n\r\nexport class TileTextureArray\r\n{\r\n    max_textures: number;\r\n    constructor(max_textures: number)\r\n    {\r\n        this.max_textures = max_textures;\r\n        this.tex_sizes = new Float32Array((this.max_textures * 4) + 4);\r\n        this.tex_buf = new Buffer({\r\n            usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST\r\n        });\r\n    }\r\n\r\n    arr: TextureSource[] = [];\r\n    count = 0;\r\n    dirty = false;\r\n    dirty_gpu = false;\r\n    bind_group: BindGroup = null;\r\n    bind_group_resources: any = {};\r\n    tex_sizes: Float32Array = null;\r\n    null_color: Float32Array = new Float32Array([0, 0, 0, 0.5]);\r\n    tex_buf: Buffer = null;\r\n\r\n    get length()\r\n    {\r\n        return this.count;\r\n    }\r\n\r\n    push(tex: TextureSource)\r\n    {\r\n        this.arr[this.count++] = tex;\r\n        this.dirty = true;\r\n    }\r\n\r\n    at(ind: number)\r\n    {\r\n        return this.arr[ind];\r\n    }\r\n\r\n    update()\r\n    {\r\n        if (!this.dirty)\r\n        {\r\n            return;\r\n        }\r\n\r\n        this.dirty = false;\r\n        this.dirty_gpu = true;\r\n\r\n        const { tex_sizes, arr, count, max_textures, null_color } = this;\r\n\r\n        for (let i = 0; i < count; i++)\r\n        {\r\n            const tex = arr[i];\r\n\r\n            if (tex)\r\n            {\r\n                tex_sizes[(i * 4)] = tex.pixelWidth;\r\n                tex_sizes[(i * 4) + 1] = tex.pixelHeight;\r\n                tex_sizes[(i * 4) + 2] = 1.0 / tex.pixelWidth;\r\n                tex_sizes[(i * 4) + 3] = 1.0 / tex.pixelHeight;\r\n            }\r\n        }\r\n\r\n        tex_sizes[max_textures * 4] = null_color[0];\r\n        tex_sizes[(max_textures * 4) + 1] = null_color[1];\r\n        tex_sizes[(max_textures * 4) + 2] = null_color[2];\r\n        tex_sizes[(max_textures * 4) + 3] = null_color[3];\r\n    }\r\n\r\n    markDirty()\r\n    {\r\n        this.dirty = true;\r\n    }\r\n\r\n    getBindGroup()\r\n    {\r\n        this.update();\r\n        if (!this.dirty_gpu)\r\n        {\r\n            return this.bind_group;\r\n        }\r\n\r\n        const { bind_group_resources, max_textures, arr, count } = this;\r\n\r\n        let bindIndex = 0;\r\n\r\n        bind_group_resources[bindIndex++] = new UniformGroup({\r\n            u_texture_size: {\r\n                value: this.tex_sizes,\r\n                type: 'vec4<f32>',\r\n                size: max_textures\r\n            },\r\n            u_null_color: {\r\n                value: this.null_color,\r\n                type: 'vec4<f32>'\r\n            },\r\n        });\r\n\r\n        for (let i = 0; i < max_textures; i++)\r\n        {\r\n            const texture = (i < count ? arr[i] : null) || Texture.EMPTY.source;\r\n\r\n            bind_group_resources[bindIndex++] = texture.source;\r\n            bind_group_resources[bindIndex++] = texture.style;\r\n        }\r\n\r\n        if (!this.bind_group)\r\n        {\r\n            this.bind_group = new BindGroup(bind_group_resources);\r\n        }\r\n\r\n        return this.bind_group;\r\n    }\r\n\r\n    static generate_gpu_textures(max_textures: number): string\r\n    {\r\n        const src: string[] = [];\r\n\r\n        src.push(`struct TextureArrayFields {`);\r\n        src.push(`    u_texture_size: array<vec4f, ${max_textures}>,`);\r\n        src.push(`    u_null_color: vec4f`);\r\n        src.push(`}`);\r\n        src.push(`@group(1) @binding(0) var<uniform> taf: TextureArrayFields;`);\r\n        for (let i = 0; i < max_textures; i++)\r\n        {\r\n            src.push(`@group(1) @binding(${(i * 2) + 1}) var u_texture_${i}: texture_2d<f32>;`);\r\n            src.push(`@group(1) @binding(${(i * 2) + 2}) var u_sampler_${i}: sampler;`);\r\n        }\r\n\r\n        src.push('fn sampleMultiTexture(texture_id: i32, uv: vec2f, dx: vec2f, dy: vec2f) -> vec4f {');\r\n        src.push(`switch texture_id {`);\r\n        for (let i = 0; i < max_textures; i++)\r\n        {\r\n            src.push(`  case ${i}: { return textureSampleGrad(u_texture_${i}, u_sampler_${i}, uv, dx, dy); }`);\r\n        }\r\n        src.push(`  default: { return taf.u_null_color; }`);\r\n        src.push('} }');\r\n\r\n        return src.join('\\n');\r\n    }\r\n\r\n    static generate_gl_textures(max_textures: number): string\r\n    {\r\n        const src: string[] = [];\r\n\r\n        src.push(`uniform vec4 u_texture_size[${max_textures + 1}];`);\r\n        src.push(`uniform sampler2D u_textures[${max_textures}];`);\r\n        src.push(`uniform vec4 u_null_color;`);\r\n\r\n        src.push('vec4 sampleMultiTexture(float texture_id, vec2 uv) {');\r\n        src.push(`if(texture_id < -0.5) return u_texture_size[${max_textures}];`);\r\n        for (let i = 0; i < max_textures; i++)\r\n        {\r\n            src.push(`if(texture_id < ${i}.5) return texture(u_textures[${i}], uv * u_texture_size[${i}].zw);`);\r\n        }\r\n        src.push(`return u_texture_size[${max_textures}];`);\r\n        src.push('}');\r\n\r\n        return src.join('\\n');\r\n    }\r\n\r\n    static gl_gen_resources(max_textures: number): any\r\n    {\r\n        const sampleValues: Array<number> = [];\r\n\r\n        for (let i = 0; i < max_textures; i++)\r\n        {\r\n            sampleValues[i] = i;\r\n        }\r\n\r\n        const samplerSize: Array<number> = [];\r\n\r\n        for (let i = 0; i < max_textures; i++)\r\n        {\r\n            // These are overwritten by TilemapRenderer when textures actually bound.\r\n            samplerSize.push(2048);\r\n            samplerSize.push(2048);\r\n            samplerSize.push(1.0 / 2048);\r\n            samplerSize.push(1.0 / 2048);\r\n        }\r\n\r\n        return {\r\n            u_textures: {\r\n                value: sampleValues,\r\n                type: 'i32',\r\n                size: max_textures\r\n            },\r\n            u_texture_size: {\r\n                value: samplerSize,\r\n                type: 'vec4<f32>',\r\n                size: max_textures\r\n            }\r\n        };\r\n    }\r\n}\r\n","import { ExtensionType, GlProgram, Shader, UniformGroup, WebGLRenderer } from 'pixi.js';\r\nimport { settings } from './settings';\r\nimport { Tilemap } from './Tilemap';\r\nimport { TilemapAdaptor, TilemapPipe } from './TilemapPipe';\r\nimport { TileTextureArray } from './TileTextureArray';\r\n\r\nconst gl_tilemap_vertex = `\r\nin vec2 aVertexPosition;\r\nin vec2 aTextureCoord;\r\nin vec4 aFrame;\r\nin vec2 aAnim;\r\nin float aAnimDivisor;\r\nin float aTextureId;\r\nin float aAlpha;\r\n\r\nuniform mat3 u_proj_trans;\r\nuniform vec2 u_anim_frame;\r\n\r\nout vec2 vTextureCoord;\r\nout float vTextureId;\r\nout vec4 vFrame;\r\nout float vAlpha;\r\n\r\nvoid main(void)\r\n{\r\n  gl_Position = vec4((u_proj_trans * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n  vec2 animCount = floor((aAnim + 0.5) / 2048.0);\r\n  vec2 animFrameOffset = aAnim - animCount * 2048.0;\r\n  vec2 currentFrame = floor(u_anim_frame / aAnimDivisor);\r\n  vec2 loop_num = floor((currentFrame + 0.5) / animCount);\r\n  vec2 animOffset = animFrameOffset * floor(currentFrame - loop_num * animCount);\r\n\r\n  vTextureCoord = aTextureCoord + animOffset;\r\n  vFrame = aFrame + vec4(animOffset, animOffset);\r\n  vTextureId = aTextureId;\r\n  vAlpha = aAlpha;\r\n}\r\n`;\r\n\r\nconst gl_tilemap_fragment = `\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\nprecision highp float;\r\n#else\r\nprecision mediump float;\r\n#endif\r\nin vec2 vTextureCoord;\r\nin vec4 vFrame;\r\nin float vTextureId;\r\nin float vAlpha;\r\n\r\n//include_textures\r\n\r\nvoid main(void)\r\n{\r\n  float textureId = floor(vTextureId + 0.5);\r\n  vec2 textureCoord = clamp(vTextureCoord, vFrame.xy, vFrame.zw);\r\n  vec4 color = sampleMultiTexture(textureId, textureCoord);\r\n  finalColor = color * vAlpha;\r\n}\r\n`;\r\n\r\nexport class GlTilemapAdaptor extends TilemapAdaptor\r\n{\r\n    public static extension = {\r\n        type: [\r\n            ExtensionType.WebGLPipesAdaptor,\r\n        ],\r\n        name: 'tilemap',\r\n    } as const;\r\n\r\n    _shader: Shader = null;\r\n    max_textures: number = settings.TEXTURES_PER_TILEMAP;\r\n\r\n    destroy(): void\r\n    {\r\n        this._shader.destroy(true);\r\n        this._shader = null;\r\n    }\r\n\r\n    execute(pipe: TilemapPipe, tilemap: Tilemap): void\r\n    {\r\n        const renderer = pipe.renderer as WebGLRenderer;\r\n        const shader = this._shader;\r\n        const tileset = tilemap.getTileset();\r\n\r\n        const tu = shader.resources.texture_uniforms;\r\n\r\n        if (tu.uniforms.u_texture_size !== tileset.tex_sizes)\r\n        {\r\n            tu.uniforms.u_texture_size = tileset.tex_sizes;\r\n            tu.update();\r\n        }\r\n\r\n        for (let i = 0; i < tileset.length; i++)\r\n        {\r\n            renderer.texture.bind(tileset.arr[i], i);\r\n        }\r\n\r\n        renderer.encoder.draw({\r\n            geometry: tilemap.vb,\r\n            shader,\r\n            state: tilemap.state,\r\n            size: tilemap.rects_count * 6\r\n        });\r\n\r\n        // TODO: support several tilemaps here, without re-setting extra uniforms\r\n    }\r\n\r\n    init(): void\r\n    {\r\n        this._shader = new Shader({\r\n            glProgram: GlProgram.from({\r\n                vertex: gl_tilemap_vertex,\r\n                fragment: gl_tilemap_fragment.replace('//include_textures',\r\n                    TileTextureArray.generate_gl_textures(this.max_textures))\r\n            }),\r\n            resources: {\r\n                texture_uniforms: new UniformGroup(TileTextureArray.gl_gen_resources(this.max_textures), { isStatic: true }),\r\n                pipe_uniforms: this.pipe_uniforms.uniformStructures,\r\n            },\r\n        });\r\n    }\r\n}\r\n","import { BindGroup, ExtensionType, GpuProgram, Shader } from 'pixi.js';\r\nimport { settings } from './settings';\r\nimport { Tilemap } from './Tilemap';\r\nimport { TilemapAdaptor, TilemapPipe } from './TilemapPipe';\r\nimport { TileTextureArray } from './TileTextureArray';\r\n\r\nconst gpu_tilemap_vertex = `\r\nstruct GlobalUniforms {\r\n  uProjectionMatrix:mat3x3f,\r\n  uWorldTransformMatrix:mat3x3f,\r\n  uWorldColorAlpha: vec4f,\r\n  uResolution: vec2f,\r\n}\r\n\r\nstruct TilemapUniforms {\r\n  u_proj_trans:mat3x3f,\r\n  u_anim_frame:vec2f\r\n}\r\n\r\n@group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\r\n@group(2) @binding(0) var<uniform> loc: TilemapUniforms;\r\n\r\nstruct VSOutput {\r\n  @builtin(position) vPosition: vec4f,\r\n  @location(0) @interpolate(flat) vTextureId : i32,\r\n  @location(1) vTextureCoord : vec2f,\r\n  @location(2) @interpolate(flat) vFrame : vec4f,\r\n  @location(3) vAlpha : f32\r\n};\r\n\r\n@vertex\r\nfn mainVert(\r\n   @location(6) aVertexPosition: vec2f,\r\n   @location(4) aTextureCoord: vec2f,\r\n   @location(3) aFrame: vec4f,\r\n   @location(1) aAnim: vec2f,\r\n   @location(2) aAnimDivisor: f32,\r\n   @location(5) aTextureId: i32,\r\n   @location(0) aAlpha: f32,\r\n ) -> VSOutput {\r\n\r\n  var vPosition = vec4((loc.u_proj_trans * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n  var animCount = floor((aAnim + 0.5) / 2048.0);\r\n  var animFrameOffset = aAnim - animCount * 2048.0;\r\n  var currentFrame = floor(loc.u_anim_frame / aAnimDivisor);\r\n  var loop_num = floor((currentFrame + 0.5) / animCount);\r\n  var animOffset = animFrameOffset * floor(currentFrame - loop_num * animCount);\r\n  var vTextureCoord = aTextureCoord + animOffset;\r\n  var vFrame = aFrame + vec4(animOffset, animOffset);\r\n\r\n  return VSOutput(vPosition, aTextureId, vTextureCoord, vFrame, aAlpha);\r\n};\r\n`;\r\n\r\nconst gpu_tilemap_fragment = `\r\n//include_textures\r\n\r\n@fragment\r\nfn mainFrag(\r\n  @location(0) @interpolate(flat) vTextureId : i32,\r\n  @location(1) vTextureCoord : vec2f,\r\n  @location(2) @interpolate(flat) vFrame : vec4f,\r\n  @location(3) vAlpha : f32,\r\n  ) -> @location(0) vec4f {\r\n  var textureCoord = clamp(vTextureCoord, vFrame.xy, vFrame.zw);\r\n  var uv = textureCoord * taf.u_texture_size[vTextureId].zw;\r\n  var dx = dpdx(uv);\r\n  var dy = dpdy(uv);\r\n  var color = sampleMultiTexture(vTextureId, uv, dx, dy);\r\n  return color * vAlpha;\r\n};\r\n`;\r\n\r\nexport class GpuTilemapAdaptor extends TilemapAdaptor\r\n{\r\n    public static extension = {\r\n        type: [\r\n            ExtensionType.WebGPUPipesAdaptor,\r\n        ],\r\n        name: 'tilemap',\r\n    } as const;\r\n\r\n    _shader: Shader = null;\r\n    max_textures: number = settings.TEXTURES_PER_TILEMAP;\r\n    bind_group: BindGroup = null;\r\n\r\n    destroy(): void\r\n    {\r\n        this._shader.destroy(true);\r\n        this._shader = null;\r\n    }\r\n\r\n    execute(pipe: TilemapPipe, tilemap: Tilemap): void\r\n    {\r\n        const renderer = pipe.renderer;\r\n        const shader = this._shader;\r\n        // GPU..\r\n\r\n        shader.groups[0] = renderer.globalUniforms.bindGroup;\r\n        shader.groups[1] = tilemap.getTileset().getBindGroup();\r\n        shader.groups[2] = this.bind_group;\r\n\r\n        renderer.encoder.draw({\r\n            geometry: tilemap.vb,\r\n            shader,\r\n            state: tilemap.state,\r\n            size: tilemap.rects_count * 6\r\n        });\r\n        // TODO: does it need groups?\r\n    }\r\n\r\n    init(): void\r\n    {\r\n        this._shader = new Shader({\r\n            gpuProgram: GpuProgram.from({\r\n                vertex: { source: gpu_tilemap_vertex, entryPoint: 'mainVert' },\r\n                fragment: {\r\n                    source: gpu_tilemap_fragment\r\n                        .replace('//include_textures', TileTextureArray.generate_gpu_textures(this.max_textures))\r\n                },\r\n            })\r\n        });\r\n\r\n        this.bind_group = new BindGroup({\r\n            ut: this.pipe_uniforms\r\n        });\r\n    }\r\n}\r\n","/* eslint-disable no-unused-vars */\r\nimport { Bounds, Container, groupD8, State, Texture, TextureSource } from 'pixi.js';\r\nimport { settings } from './settings';\r\nimport { TilemapInstruction, TilemapPipe } from './TilemapPipe';\r\nimport { TileTextureArray } from './TileTextureArray';\r\n\r\nimport type { DestroyOptions } from 'pixi.js';\r\nimport type { TilemapGeometry } from './TilemapGeometry';\r\n\r\nenum POINT_STRUCT\r\n    {\r\n    U,\r\n    V,\r\n    X,\r\n    Y,\r\n    TILE_WIDTH,\r\n    TILE_HEIGHT,\r\n    ROTATE,\r\n    ANIM_X,\r\n    ANIM_Y,\r\n    TEXTURE_INDEX,\r\n    ANIM_COUNT_X,\r\n    ANIM_COUNT_Y,\r\n    ANIM_DIVISOR,\r\n    ALPHA,\r\n}\r\n\r\nexport const POINT_STRUCT_SIZE = (Object.keys(POINT_STRUCT).length / 2);\r\n\r\n/**\r\n * A rectangular tilemap implementation that renders a predefined set of tile textures.\r\n *\r\n * The {@link Tilemap.tileset tileset} of a tilemap defines the list of base-textures that can be painted in the\r\n * tilemap. A texture is identified using its base-texture's index into the this list, i.e. changing the base-texture\r\n * at a given index in the tileset modifies the paint of all tiles pointing to that index.\r\n *\r\n * The size of the tileset is limited by the texture units supported by the client device. The minimum supported\r\n * value is 8, as defined by the WebGL 1 specification. `gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS`) can be used\r\n * to extract this limit. {@link CompositeTilemap} can be used to get around this limit by layering multiple tilemap\r\n * instances.\r\n *\r\n * @example\r\n * import { Tilemap } from '@pixi/tilemap';\r\n * import { Loader } from '@pixi/loaders';\r\n *\r\n * // Add the spritesheet into your loader!\r\n * Loader.shared.add('atlas', 'assets/atlas.json');\r\n *\r\n * // Make the tilemap once the tileset assets are available.\r\n * Loader.shared.load(function onTilesetLoaded()\r\n * {\r\n *      // The base-texture is shared between all the tile textures.\r\n *      const tilemap = new Tilemap([Texture.from('grass.png').baseTexture])\r\n *          .tile('grass.png', 0, 0)\r\n *          .tile('grass.png', 100, 100)\r\n *          .tile('brick_wall.png', 0, 100);\r\n * });\r\n */\r\nexport class Tilemap extends Container\r\n{\r\n    // TODO: make default color work\r\n    /**\r\n     * Currently doesnt work.\r\n     */\r\n    shadowColor = new Float32Array([0.0, 0.0, 0.0, 0.5]);\r\n    state = State.for2d();\r\n\r\n    is_valid = false;\r\n\r\n    public readonly renderPipeId = 'tilemap';\r\n    public readonly canBundle = true;\r\n\r\n    _instruction = {\r\n        renderPipeId: 'tilemap',\r\n        tilemap: this as Tilemap\r\n    } as TilemapInstruction;\r\n\r\n    /**\r\n     * @internal\r\n     * @ignore\r\n     */\r\n    checkValid()\r\n    {\r\n        const v = this.tileset.count > 0 && this.pointsBuf.length > 0;\r\n        const res = this.is_valid !== v;\r\n\r\n        this.is_valid = v;\r\n\r\n        return res !== v;\r\n    }\r\n\r\n    /**\r\n     * The tile animation frame.\r\n     *\r\n     * @see CompositeTilemap.tileAnim\r\n     */\r\n    public tileAnim: [number, number] = null;\r\n\r\n    /**\r\n     * This is the last uploaded size of the tilemap geometry.\r\n     * @ignore\r\n     */\r\n    rects_count = 0;\r\n\r\n    /** @ignore */\r\n    compositeParent = false;\r\n\r\n    /**\r\n     * The list of base-textures being used in the tilemap.\r\n     *\r\n     * This should not be shuffled after tiles have been added into this tilemap. Usually, only tile textures\r\n     * should be added after tiles have been added into the map.\r\n     */\r\n    protected tileset = new TileTextureArray(settings.TEXTURES_PER_TILEMAP);\r\n\r\n    /**\r\n     * The local bounds of the tilemap itself. This does not include DisplayObject children.\r\n     */\r\n    protected readonly tilemapBounds = new Bounds();\r\n\r\n    /** Flags whether any animated tile was added. */\r\n    protected hasAnimatedTile = false;\r\n\r\n    /** The interleaved geometry of the tilemap. */\r\n    private pointsBuf: Array<number> = [];\r\n\r\n    /**\r\n     * @param tileset - The tileset to use for the tilemap. This can be reset later with {@link Tilemap.setTileset}. The\r\n     *      base-textures in this array must not be duplicated.\r\n     */\r\n    constructor(tileset: TextureSource | Array<TextureSource>)\r\n    {\r\n        super();\r\n        this.setTileset(tileset);\r\n    }\r\n\r\n    /**\r\n     * @returns The tileset of this tilemap.\r\n     */\r\n    getTileset(): TileTextureArray\r\n    {\r\n        return this.tileset;\r\n    }\r\n\r\n    /**\r\n     * Define the tileset used by the tilemap.\r\n     *\r\n     * @param textureOrArray - The list of textures to use in the tilemap. If a base-texture (not array) is passed, it will\r\n     *  be wrapped into an array. This should not contain any duplicates.\r\n     */\r\n    setTileset(textureOrArray: TileTextureArray | TextureSource | Array<TextureSource> = []): this\r\n    {\r\n        let ts = this.tileset;\r\n\r\n        if (textureOrArray instanceof TileTextureArray)\r\n        {\r\n            this.tileset = textureOrArray;\r\n            this.didViewUpdate = true;\r\n        }\r\n        else if (textureOrArray instanceof TextureSource)\r\n        {\r\n            if (ts.count === 1 && ts.arr[0] === textureOrArray)\r\n            {\r\n                return this;\r\n            }\r\n\r\n            ts = this.tileset = new TileTextureArray(settings.TEXTURES_PER_TILEMAP);\r\n            ts.push(textureOrArray);\r\n            this.didViewUpdate = true;\r\n        }\r\n        else\r\n        {\r\n            if (textureOrArray.length === ts.count)\r\n            {\r\n                let flag = true;\r\n\r\n                for (let i = 0; i < textureOrArray.length; i++)\r\n                {\r\n                    if (textureOrArray[i]?.source !== ts.arr[i])\r\n                    {\r\n                        flag = false;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (flag)\r\n                {\r\n                    return this;\r\n                }\r\n            }\r\n\r\n            ts = this.tileset = new TileTextureArray(settings.TEXTURES_PER_TILEMAP);\r\n\r\n            for (let i = 0; i < textureOrArray.length; i++)\r\n            {\r\n                ts.push(textureOrArray[i]?.source);\r\n            }\r\n            this.didViewUpdate = true;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**  Clears all the tiles added into this tilemap. */\r\n    clear(): this\r\n    {\r\n        this.pointsBuf.length = 0;\r\n        this.rects_count = 0;\r\n        this.tilemapBounds.clear();\r\n        this.hasAnimatedTile = false;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a tile that paints the given texture at (x, y).\r\n     *\r\n     * @param tileTexture - The tiling texture to render.\r\n     * @param x - The local x-coordinate of the tile's position.\r\n     * @param y - The local y-coordinate of the tile's position.\r\n     * @param options - Additional tile options.\r\n     * @param [options.u=texture.frame.x] - The x-coordinate of the texture in its base-texture's space.\r\n     * @param [options.v=texture.frame.y] - The y-coordinate of the texture in its base-texture's space.\r\n     * @param [options.tileWidth=texture.orig.width] - The local width of the tile.\r\n     * @param [options.tileHeight=texture.orig.height] - The local height of the tile.\r\n     * @param [options.animX=0] - For animated tiles, this is the \"offset\" along the x-axis for adjacent\r\n     *      animation frame textures in the base-texture.\r\n     * @param [options.animY=0] - For animated tiles, this is the \"offset\" along the y-axis for adjacent\r\n     *      animation frames textures in the base-texture.\r\n     * @param [options.rotate=0]\r\n     * @param [options.animCountX=1024] - For animated tiles, this is the number of animation frame textures\r\n     *      per row.\r\n     * @param [options.animCountY=1024] - For animated tiles, this is the number of animation frame textures\r\n     *      per column.\r\n     * @param [options.animDivisor=1] - For animated tiles, this is the animation duration of each frame\r\n     * @param [options.alpha=1] - Tile alpha\r\n     * @return This tilemap, good for chaining.\r\n     */\r\n    tile(\r\n        tileTexture: number | string | Texture | TextureSource,\r\n        x: number,\r\n        y: number,\r\n        options: {\r\n            u?: number,\r\n            v?: number,\r\n            tileWidth?: number,\r\n            tileHeight?: number,\r\n            animX?: number,\r\n            animY?: number,\r\n            rotate?: number,\r\n            animCountX?: number,\r\n            animCountY?: number,\r\n            animDivisor?: number,\r\n            alpha?: number,\r\n        } = {}\r\n    ): this\r\n    {\r\n        this.didViewUpdate = true;\r\n        let baseTexture: TextureSource;\r\n        let textureIndex = -1;\r\n        let was_num = false;\r\n\r\n        if (typeof tileTexture === 'number')\r\n        {\r\n            textureIndex = tileTexture;\r\n            was_num = true;\r\n            baseTexture = this.tileset.arr[textureIndex];\r\n        }\r\n        else\r\n        {\r\n            let texture: Texture | TextureSource;\r\n\r\n            if (typeof tileTexture === 'string')\r\n            {\r\n                texture = Texture.from(tileTexture);\r\n            }\r\n            else\r\n            {\r\n                texture = tileTexture;\r\n            }\r\n\r\n            const textureList = this.tileset;\r\n\r\n            for (let i = 0; i < textureList.count; i++)\r\n            {\r\n                if (textureList.arr[i] === texture.source)\r\n                {\r\n                    textureIndex = i;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if ('frame' in texture)\r\n            {\r\n                options.u = options.u ?? texture.frame.x;\r\n                options.v = options.v ?? texture.frame.y;\r\n                options.tileWidth = options.tileWidth ?? texture.orig.width;\r\n                options.tileHeight = options.tileHeight ?? texture.orig.height;\r\n            }\r\n\r\n            baseTexture = texture.source;\r\n        }\r\n\r\n        if (!was_num && !baseTexture)\r\n        {\r\n            console.error('The tile texture was not found in the tilemap tileset.');\r\n\r\n            return this;\r\n        }\r\n\r\n        const {\r\n            u = 0,\r\n            v = 0,\r\n            tileWidth = baseTexture.width,\r\n            tileHeight = baseTexture.height,\r\n            animX = 0,\r\n            animY = 0,\r\n            rotate = 0,\r\n            animCountX = 1024,\r\n            animCountY = 1024,\r\n            animDivisor = 1,\r\n            alpha = 1,\r\n        } = options;\r\n\r\n        const pb = this.pointsBuf;\r\n\r\n        this.hasAnimatedTile = this.hasAnimatedTile || animX > 0 || animY > 0;\r\n\r\n        pb.push(u);\r\n        pb.push(v);\r\n        pb.push(x);\r\n        pb.push(y);\r\n        pb.push(tileWidth);\r\n        pb.push(tileHeight);\r\n        pb.push(rotate);\r\n        pb.push(animX | 0);\r\n        pb.push(animY | 0);\r\n        pb.push(textureIndex);\r\n        pb.push(animCountX);\r\n        pb.push(animCountY);\r\n        pb.push(animDivisor);\r\n        pb.push(alpha);\r\n\r\n        this.tilemapBounds.addFrame(x, y, x + tileWidth, y + tileHeight);\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Changes the rotation of the last tile. */\r\n    tileRotate(rotate: number): void\r\n    {\r\n        const pb = this.pointsBuf;\r\n\r\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.TEXTURE_INDEX)] = rotate;\r\n    }\r\n\r\n    /** Changes the `animX`, `animCountX` of the last tile. */\r\n    tileAnimX(offset: number, count: number): void\r\n    {\r\n        const pb = this.pointsBuf;\r\n\r\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_X)] = offset;\r\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_COUNT_X)] = count;\r\n        // pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_DIVISOR)] = duration;\r\n    }\r\n\r\n    /** Changes the `animY`, `animCountY` of the last tile. */\r\n    tileAnimY(offset: number, count: number): void\r\n    {\r\n        const pb = this.pointsBuf;\r\n\r\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_Y)] = offset;\r\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_COUNT_Y)] = count;\r\n    }\r\n\r\n    /** Changes the `animDivisor` value of the last tile. */\r\n    tileAnimDivisor(divisor: number): void\r\n    {\r\n        const pb = this.pointsBuf;\r\n\r\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_DIVISOR)] = divisor;\r\n    }\r\n\r\n    tileAlpha(alpha: number): void\r\n    {\r\n        const pb = this.pointsBuf;\r\n\r\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ALPHA)] = alpha;\r\n    }\r\n\r\n    private vbId = 0;\r\n    vb: TilemapGeometry = null;\r\n    private vbBuffer: ArrayBuffer = null;\r\n    private vbArray: Float32Array = null;\r\n    private vbInts: Uint32Array = null;\r\n\r\n    private destroyVb(): void\r\n    {\r\n        if (this.vb)\r\n        {\r\n            this.vb.destroy();\r\n            this.vb = null;\r\n        }\r\n    }\r\n\r\n    updateBuffer(plugin: TilemapPipe)\r\n    {\r\n        const points = this.pointsBuf;\r\n        const rects_count = points.length / POINT_STRUCT_SIZE;\r\n        let vb = this.vb;\r\n\r\n        if (this.tileset.count === 0 || rects_count === 0 || (this.rects_count === rects_count && vb))\r\n        {\r\n            return;\r\n        }\r\n        this.rects_count = rects_count;\r\n\r\n        // lost context! recover!\r\n\r\n        if (!vb)\r\n        {\r\n            vb = plugin.createVb();\r\n            this.vb = vb;\r\n            this.vbId = (vb as any).id;\r\n            this.vbBuffer = null;\r\n        }\r\n\r\n        // if layer was changed, re-upload vertices\r\n        const vertices = rects_count * vb.vertPerQuad;\r\n\r\n        plugin.checkIndexBuffer(rects_count);\r\n\r\n        const vertexBuf = vb.getBuffer('aVertexPosition');\r\n        const vs = vb.stride * vertices;\r\n\r\n        if (!this.vbBuffer || this.vbBuffer.byteLength < vs)\r\n        {\r\n            // !@#$ happens, need resize\r\n            let bk = vb.stride;\r\n\r\n            while (bk < vs)\r\n            {\r\n                bk *= 2;\r\n            }\r\n            this.vbBuffer = new ArrayBuffer(bk);\r\n            this.vbArray = new Float32Array(this.vbBuffer);\r\n            this.vbInts = new Uint32Array(this.vbBuffer);\r\n        }\r\n\r\n        const arr = this.vbArray;\r\n        const ints = this.vbInts;\r\n        let sz = 0;\r\n        let textureId = 0;\r\n\r\n        for (let i = 0; i < points.length; i += POINT_STRUCT_SIZE)\r\n        {\r\n            const eps = 0.5;\r\n\r\n            if (this.compositeParent)\r\n            {\r\n                textureId = points[i + POINT_STRUCT.TEXTURE_INDEX];\r\n            }\r\n            const x = points[i + POINT_STRUCT.X];\r\n            const y = points[i + POINT_STRUCT.Y];\r\n            const w = points[i + POINT_STRUCT.TILE_WIDTH];\r\n            const h = points[i + POINT_STRUCT.TILE_HEIGHT];\r\n            const u = points[i + POINT_STRUCT.U];\r\n            const v = points[i + POINT_STRUCT.V];\r\n            let rotate = points[i + POINT_STRUCT.ROTATE];\r\n\r\n            const animX = points[i + POINT_STRUCT.ANIM_X];\r\n            const animY = points[i + POINT_STRUCT.ANIM_Y];\r\n            const animWidth = points[i + POINT_STRUCT.ANIM_COUNT_X] || 1024;\r\n            const animHeight = points[i + POINT_STRUCT.ANIM_COUNT_Y] || 1024;\r\n\r\n            const animXEncoded = animX + (animWidth * 2048);\r\n            const animYEncoded = animY + (animHeight * 2048);\r\n            const animDivisor = points[i + POINT_STRUCT.ANIM_DIVISOR];\r\n            const alpha = points[i + POINT_STRUCT.ALPHA];\r\n\r\n            let u0: number;\r\n            let v0: number; let u1: number;\r\n            let v1: number; let u2: number;\r\n            let v2: number; let u3: number;\r\n            let v3: number;\r\n\r\n            if (rotate === 0)\r\n            {\r\n                u0 = u;\r\n                v0 = v;\r\n                u1 = u + w;\r\n                v1 = v;\r\n                u2 = u + w;\r\n                v2 = v + h;\r\n                u3 = u;\r\n                v3 = v + h;\r\n            }\r\n            else\r\n            {\r\n                let w2 = w / 2;\r\n                let h2 = h / 2;\r\n\r\n                if (rotate % 4 !== 0)\r\n                {\r\n                    w2 = h / 2;\r\n                    h2 = w / 2;\r\n                }\r\n                const cX = u + w2;\r\n                const cY = v + h2;\r\n\r\n                rotate = groupD8.add(rotate, groupD8.NW);\r\n                u0 = cX + (w2 * groupD8.uX(rotate));\r\n                v0 = cY + (h2 * groupD8.uY(rotate));\r\n\r\n                rotate = groupD8.add(rotate, 2); // rotate 90 degrees clockwise\r\n                u1 = cX + (w2 * groupD8.uX(rotate));\r\n                v1 = cY + (h2 * groupD8.uY(rotate));\r\n\r\n                rotate = groupD8.add(rotate, 2);\r\n                u2 = cX + (w2 * groupD8.uX(rotate));\r\n                v2 = cY + (h2 * groupD8.uY(rotate));\r\n\r\n                rotate = groupD8.add(rotate, 2);\r\n                u3 = cX + (w2 * groupD8.uX(rotate));\r\n                v3 = cY + (h2 * groupD8.uY(rotate));\r\n            }\r\n\r\n            arr[sz++] = x;\r\n            arr[sz++] = y;\r\n            arr[sz++] = u0;\r\n            arr[sz++] = v0;\r\n            arr[sz++] = u + eps;\r\n            arr[sz++] = v + eps;\r\n            arr[sz++] = u + w - eps;\r\n            arr[sz++] = v + h - eps;\r\n            arr[sz++] = animXEncoded;\r\n            arr[sz++] = animYEncoded;\r\n            ints[sz++] = textureId;\r\n            arr[sz++] = animDivisor;\r\n            arr[sz++] = alpha;\r\n\r\n            arr[sz++] = x + w;\r\n            arr[sz++] = y;\r\n            arr[sz++] = u1;\r\n            arr[sz++] = v1;\r\n            arr[sz++] = u + eps;\r\n            arr[sz++] = v + eps;\r\n            arr[sz++] = u + w - eps;\r\n            arr[sz++] = v + h - eps;\r\n            arr[sz++] = animXEncoded;\r\n            arr[sz++] = animYEncoded;\r\n            ints[sz++] = textureId;\r\n            arr[sz++] = animDivisor;\r\n            arr[sz++] = alpha;\r\n\r\n            arr[sz++] = x + w;\r\n            arr[sz++] = y + h;\r\n            arr[sz++] = u2;\r\n            arr[sz++] = v2;\r\n            arr[sz++] = u + eps;\r\n            arr[sz++] = v + eps;\r\n            arr[sz++] = u + w - eps;\r\n            arr[sz++] = v + h - eps;\r\n            arr[sz++] = animXEncoded;\r\n            arr[sz++] = animYEncoded;\r\n            ints[sz++] = textureId;\r\n            arr[sz++] = animDivisor;\r\n            arr[sz++] = alpha;\r\n\r\n            arr[sz++] = x;\r\n            arr[sz++] = y + h;\r\n            arr[sz++] = u3;\r\n            arr[sz++] = v3;\r\n            arr[sz++] = u + eps;\r\n            arr[sz++] = v + eps;\r\n            arr[sz++] = u + w - eps;\r\n            arr[sz++] = v + h - eps;\r\n            arr[sz++] = animXEncoded;\r\n            arr[sz++] = animYEncoded;\r\n            ints[sz++] = textureId;\r\n            arr[sz++] = animDivisor;\r\n            arr[sz++] = alpha;\r\n        }\r\n\r\n        vertexBuf.data = arr;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @ignore\r\n     */\r\n    isModified(anim: boolean): boolean\r\n    {\r\n        if (this.rects_count * POINT_STRUCT_SIZE !== this.pointsBuf.length\r\n            || (anim && this.hasAnimatedTile))\r\n        {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * This will pull forward the modification marker.\r\n     *\r\n     * @internal\r\n     * @ignore\r\n     */\r\n    clearModify(): void\r\n    {\r\n        this.rects_count = this.pointsBuf.length / POINT_STRUCT_SIZE;\r\n    }\r\n\r\n    public addBounds(bounds: Bounds)\r\n    {\r\n        const _bounds = this.tilemapBounds;\r\n\r\n        bounds.addFrame(_bounds.minX, _bounds.minY, _bounds.maxX, _bounds.maxY);\r\n    }\r\n\r\n    get bounds()\r\n    {\r\n        return this.tilemapBounds;\r\n    }\r\n\r\n    /** @override */\r\n    destroy(options?: DestroyOptions): void\r\n    {\r\n        super.destroy(options);\r\n        this.destroyVb();\r\n    }\r\n\r\n    /**\r\n     * Deprecated signature for {@link Tilemap.tile tile}.\r\n     *\r\n     * @deprecated Since @pixi/tilemap 3.\r\n     */\r\n    addFrame(texture: Texture | string | number, x: number, y: number, animX: number, animY: number): boolean\r\n    {\r\n        this.tile(\r\n            texture,\r\n            x,\r\n            y,\r\n            {\r\n                animX,\r\n                animY,\r\n            }\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Deprecated signature for {@link Tilemap.tile tile}.\r\n     *\r\n     * @deprecated Since @pixi/tilemap 3.\r\n     */\r\n    // eslint-disable-next-line max-params\r\n    addRect(\r\n        textureIndex: number,\r\n        u: number,\r\n        v: number,\r\n        x: number,\r\n        y: number,\r\n        tileWidth: number,\r\n        tileHeight: number,\r\n        animX = 0,\r\n        animY = 0,\r\n        rotate = 0,\r\n        animCountX = 1024,\r\n        animCountY = 1024,\r\n        animDivisor = 1,\r\n        alpha = 1,\r\n    ): this\r\n    {\r\n        return this.tile(\r\n            textureIndex,\r\n            x, y,\r\n            {\r\n                u, v, tileWidth, tileHeight, animX, animY, rotate, animCountX, animCountY, animDivisor, alpha\r\n            }\r\n        );\r\n    }\r\n}\r\n","import { Container, Texture, TextureSource } from 'pixi.js';\r\nimport { settings } from './settings';\r\nimport { Tilemap } from './Tilemap';\r\n\r\n/**\r\n * A tilemap composite that lazily builds tilesets layered into multiple tilemaps.\r\n *\r\n * The composite tileset is the concatenation of the individual tilesets used in the tilemaps. You can\r\n * preinitialized it by passing a list of tile textures to the constructor. Otherwise, the composite tilemap\r\n * is lazily built as you add more tiles with newer tile textures. A new tilemap is created once the last\r\n * tilemap has reached its limit (as set by {@link CompositeTilemap.texturesPerTilemap texturesPerTilemap}).\r\n *\r\n * @example\r\n * import { Application } from '@pixi/app';\r\n * import { CompositeTilemap } from '@pixi/tilemap';\r\n * import { Loader } from '@pixi/loaders';\r\n *\r\n * // Setup view & stage.\r\n * const app = new Application();\r\n *\r\n * document.body.appendChild(app.renderer.view);\r\n * app.stage.interactive = true;\r\n *\r\n * // Global reference to the tilemap.\r\n * let globalTilemap: CompositeTilemap;\r\n *\r\n * // Load the tileset spritesheet!\r\n * Loader.shared.load('atlas.json');\r\n *\r\n * // Initialize the tilemap scene when the assets load.\r\n * Loader.shared.load(function onTilesetLoaded()\r\n * {\r\n *      const tilemap = new CompositeTilemap();\r\n *\r\n *      // Setup the game level with grass and dungeons!\r\n *      for (let x = 0; x < 10; x++)\r\n *      {\r\n *          for (let y = 0; y < 10; y++)\r\n *          {\r\n *              tilemap.tile(\r\n *                  x % 2 === 0 && (x === y || x + y === 10) ? 'dungeon.png' : 'grass.png',\r\n *                  x * 100,\r\n *                  y * 100,\r\n *              );\r\n *          }\r\n *      }\r\n *\r\n *      globalTilemap = app.stage.addChild(tilemap);\r\n * });\r\n *\r\n * // Show a bomb at a random location whenever the user clicks!\r\n * app.stage.on('click', function onClick()\r\n * {\r\n *      if (!globalTilemap) return;\r\n *\r\n *      const x = Math.floor(Math.random() * 10);\r\n *      const y = Math.floor(Math.random() * 10);\r\n *\r\n *      globalTilemap.tile('bomb.png', x * 100, y * 100);\r\n * });\r\n */\r\nexport class CompositeTilemap extends Container\r\n{\r\n    /** The hard limit on the number of tile textures used in each tilemap. */\r\n    public readonly texturesPerTilemap: number;\r\n\r\n    /**\r\n     * The animation frame vector.\r\n     *\r\n     * Animated tiles have four parameters - `animX`, `animY`, `animCountX`, `animCountY`. The textures\r\n     * of adjacent animation frames are at offset `animX` or `animY` of each other, with `animCountX` per\r\n     * row and `animCountY` per column.\r\n     *\r\n     * The animation frame vector specifies which animation frame texture to use. If the x/y coordinate is\r\n     * larger than the `animCountX` or `animCountY` for a specific tile, the modulus is taken.\r\n     */\r\n    public tileAnim: [number, number] = null;\r\n\r\n    /** The last modified tilemap. */\r\n    protected lastModifiedTilemap: Tilemap = null;\r\n\r\n    private modificationMarker = 0;\r\n    // private shadowColor = new Float32Array([0.0, 0.0, 0.0, 0.5]);\r\n\r\n    /**\r\n     * @param tileset - A list of tile base-textures that will be used to eagerly initialized the layered\r\n     *  tilemaps. This is only an performance optimization, and using {@link CompositeTilemap.tile tile}\r\n     *  will work equivalently.\r\n     */\r\n    constructor(tileset?: Array<TextureSource>)\r\n    {\r\n        super();\r\n\r\n        this.tileset(tileset);\r\n        this.texturesPerTilemap = settings.TEXTURES_PER_TILEMAP;\r\n    }\r\n\r\n    /**\r\n     * This will preinitialize the tilesets of the layered tilemaps.\r\n     *\r\n     * If used after a tilemap has been created (or a tile added), this will overwrite the tile textures of the\r\n     * existing tilemaps. Passing the tileset to the constructor instead is the best practice.\r\n     *\r\n     * @param tileTextures - The list of tile textures that make up the tileset.\r\n     */\r\n    tileset(tileTextures: Array<TextureSource>): this\r\n    {\r\n        if (!tileTextures)\r\n        {\r\n            tileTextures = [];\r\n        }\r\n\r\n        const texPerChild = this.texturesPerTilemap;\r\n        const len1 = this.children.length;\r\n        const len2 = Math.ceil(tileTextures.length / texPerChild);\r\n\r\n        for (let i = 0; i < Math.min(len1, len2); i++)\r\n        {\r\n            (this.children[i] as Tilemap).setTileset(\r\n                tileTextures.slice(i * texPerChild, (i + 1) * texPerChild)\r\n            );\r\n        }\r\n        for (let i = len1; i < len2; i++)\r\n        {\r\n            const tilemap = new Tilemap(tileTextures.slice(i * texPerChild, (i + 1) * texPerChild));\r\n\r\n            tilemap.compositeParent = true;\r\n\r\n            // TODO: Don't use children\r\n            this.addChild(tilemap);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Clears the tilemap composite. */\r\n    clear(): this\r\n    {\r\n        for (let i = 0; i < this.children.length; i++)\r\n        {\r\n            (this.children[i] as Tilemap).clear();\r\n        }\r\n\r\n        this.modificationMarker = 0;\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Changes the rotation of the last added tile. */\r\n    tileRotate(rotate: number): this\r\n    {\r\n        if (this.lastModifiedTilemap)\r\n        {\r\n            this.lastModifiedTilemap.tileRotate(rotate);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Changes `animX`, `animCountX` of the last added tile. */\r\n    tileAnimX(offset: number, count: number): this\r\n    {\r\n        if (this.lastModifiedTilemap)\r\n        {\r\n            this.lastModifiedTilemap.tileAnimX(offset, count);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Changes `animY`, `animCountY` of the last added tile. */\r\n    tileAnimY(offset: number, count: number): this\r\n    {\r\n        if (this.lastModifiedTilemap)\r\n        {\r\n            this.lastModifiedTilemap.tileAnimY(offset, count);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Changes `tileAnimDivisor` value of the last added tile. */\r\n    tileAnimDivisor(divisor: number): this\r\n    {\r\n        if (this.lastModifiedTilemap)\r\n        {\r\n            this.lastModifiedTilemap.tileAnimDivisor(divisor);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a tile that paints the given tile texture at (x, y).\r\n     *\r\n     * @param tileTexture - The tile texture. You can pass an index into the composite tilemap as well.\r\n     * @param x - The local x-coordinate of the tile's location.\r\n     * @param y - The local y-coordinate of the tile's location.\r\n     * @param options - Additional options to pass to {@link Tilemap.tile}.\r\n     * @param [options.u=texture.frame.x] - The x-coordinate of the texture in its base-texture's space.\r\n     * @param [options.v=texture.frame.y] - The y-coordinate of the texture in its base-texture's space.\r\n     * @param [options.tileWidth=texture.orig.width] - The local width of the tile.\r\n     * @param [options.tileHeight=texture.orig.height] - The local height of the tile.\r\n     * @param [options.animX=0] - For animated tiles, this is the \"offset\" along the x-axis for adjacent\r\n     *      animation frame textures in the base-texture.\r\n     * @param [options.animY=0] - For animated tiles, this is the \"offset\" along the y-axis for adjacent\r\n     *      animation frames textures in the base-texture.\r\n     * @param [options.rotate=0]\r\n     * @param [options.animCountX=1024] - For animated tiles, this is the number of animation frame textures\r\n     *      per row.\r\n     * @param [options.animCountY=1024] - For animated tiles, this is the number of animation frame textures\r\n     *      per column.\r\n     * @param [options.animDivisor=1] - For animated tiles, this is the animation duration each frame\r\n     * @param [options.alpha=1] - Tile alpha\r\n     * @return This tilemap, good for chaining.\r\n     */\r\n    tile(\r\n        tileTexture: Texture | string | number,\r\n        x: number,\r\n        y: number,\r\n        options: {\r\n            u?: number,\r\n            v?: number,\r\n            tileWidth?: number,\r\n            tileHeight?: number,\r\n            animX?: number,\r\n            animY?: number,\r\n            rotate?: number,\r\n            animCountX?: number,\r\n            animCountY?: number,\r\n            animDivisor?: number,\r\n            alpha?: number,\r\n        } = {}\r\n    ): this\r\n    {\r\n        let tilemap: Tilemap = null;\r\n        const children = this.children;\r\n\r\n        this.lastModifiedTilemap = null;\r\n\r\n        if (typeof tileTexture === 'number')\r\n        {\r\n            const childIndex = tileTexture / this.texturesPerTilemap >> 0;\r\n            let tileIndex = 0;\r\n\r\n            tilemap = children[childIndex] as Tilemap;\r\n\r\n            if (!tilemap)\r\n            {\r\n                tilemap = children[0] as Tilemap;\r\n\r\n                // Silently fail if the tilemap doesn't exist\r\n                if (!tilemap) return this;\r\n\r\n                tileIndex = 0;\r\n            }\r\n            else\r\n            {\r\n                tileIndex = tileTexture % this.texturesPerTilemap;\r\n            }\r\n\r\n            tilemap.tile(\r\n                tileIndex,\r\n                x,\r\n                y,\r\n                options,\r\n            );\r\n        }\r\n        else\r\n        {\r\n            if (typeof tileTexture === 'string')\r\n            {\r\n                tileTexture = Texture.from(tileTexture);\r\n            }\r\n\r\n            // Probe all tilemaps to find which tileset contains the base-texture.\r\n            for (let i = 0; i < children.length; i++)\r\n            {\r\n                const child = children[i] as Tilemap;\r\n                const tex = child.getTileset().arr;\r\n\r\n                for (let j = 0; j < tex.length; j++)\r\n                {\r\n                    if (tex[j] === tileTexture.source)\r\n                    {\r\n                        tilemap = child;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (tilemap)\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // If no tileset contains the base-texture, attempt to add it.\r\n            if (!tilemap)\r\n            {\r\n                // Probe the tilemaps to find one below capacity. If so, add the texture into that tilemap.\r\n                for (let i = children.length - 1; i >= 0; i--)\r\n                {\r\n                    const child = children[i] as Tilemap;\r\n\r\n                    if (child.getTileset().count < this.texturesPerTilemap)\r\n                    {\r\n                        tilemap = child;\r\n                        child.getTileset().push(tileTexture.source);\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                // Otherwise, create a new tilemap initialized with that tile texture.\r\n                if (!tilemap)\r\n                {\r\n                    tilemap = new Tilemap(tileTexture.source);\r\n                    tilemap.compositeParent = true;\r\n\r\n                    this.addChild(tilemap);\r\n                }\r\n            }\r\n\r\n            tilemap.tile(\r\n                tileTexture,\r\n                x,\r\n                y,\r\n                options,\r\n            );\r\n        }\r\n\r\n        this.lastModifiedTilemap = tilemap;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @ignore\r\n     */\r\n    isModified(anim: boolean): boolean\r\n    {\r\n        const layers = this.children;\r\n\r\n        if (this.modificationMarker !== layers.length)\r\n        {\r\n            return true;\r\n        }\r\n        for (let i = 0; i < layers.length; i++)\r\n        {\r\n            if ((layers[i] as Tilemap).isModified(anim))\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @ignore\r\n     */\r\n    clearModify(): void\r\n    {\r\n        const layers = this.children;\r\n\r\n        this.modificationMarker = layers.length;\r\n        for (let i = 0; i < layers.length; i++)\r\n        {\r\n            (layers[i] as Tilemap).clearModify();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @deprecated Since @pixi/tilemap 3.\r\n     * @see CompositeTilemap.tile\r\n     */\r\n    addFrame(\r\n        texture: Texture | string | number,\r\n        x: number,\r\n        y: number,\r\n        animX?: number,\r\n        animY?: number,\r\n        animWidth?: number,\r\n        animHeight?: number,\r\n        animDivisor?: number,\r\n        alpha?: number\r\n    ): this\r\n    {\r\n        return this.tile(\r\n            texture,\r\n            x, y,\r\n            {\r\n                animX,\r\n                animY,\r\n                animCountX: animWidth,\r\n                animCountY: animHeight,\r\n                animDivisor,\r\n                alpha\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @deprecated @pixi/tilemap 3\r\n     * @see CompositeTilemap.tile\r\n     */\r\n    // eslint-disable-next-line max-params\r\n    addRect(\r\n        textureIndex: number,\r\n        u: number,\r\n        v: number,\r\n        x: number,\r\n        y: number,\r\n        tileWidth: number,\r\n        tileHeight: number,\r\n        animX?: number,\r\n        animY?: number,\r\n        rotate?: number,\r\n        animWidth?: number,\r\n        animHeight?: number\r\n    ): this\r\n    {\r\n        const childIndex: number = textureIndex / this.texturesPerTilemap >> 0;\r\n        const textureId: number = textureIndex % this.texturesPerTilemap;\r\n\r\n        if (this.children[childIndex] && (this.children[childIndex] as Tilemap).getTileset().count > 0)\r\n        {\r\n            this.lastModifiedTilemap = (this.children[childIndex] as Tilemap);\r\n            this.lastModifiedTilemap.addRect(\r\n                textureId, u, v, x, y, tileWidth, tileHeight, animX, animY, rotate, animWidth, animHeight\r\n            );\r\n        }\r\n        else\r\n        {\r\n            this.lastModifiedTilemap = null;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Alias for {@link CompositeTilemap.tileset tileset}.\r\n     *\r\n     * @deprecated Since @pixi/tilemap 3.\r\n     */\r\n    setBitmaps = this.tileset;\r\n\r\n    /**\r\n     * @deprecated Since @pixi/tilemap 3.\r\n     * @readonly\r\n     * @see CompositeTilemap.texturesPerTilemap\r\n     */\r\n    get texPerChild(): number { return this.texturesPerTilemap; }\r\n}\r\n","// Prevent SCALE_MODES from becoming lazy import in Constant.ts - which causes a import() in the declaration file,\r\n// which causes API extractor to fail https://github.com/microsoft/rushstack/issues/2140\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars, no-unused-vars\r\nimport { extensions } from 'pixi.js';\r\nimport { GlTilemapAdaptor } from './gl_tilemap';\r\nimport { GpuTilemapAdaptor } from './gpu_tilemap';\r\nimport { TilemapPipe } from './TilemapPipe';\r\n\r\nexport * from './CompositeTilemap';\r\nexport * from './settings';\r\nexport * from './Tilemap';\r\nexport * from './TilemapGeometry';\r\nexport * from './TilemapPipe';\r\n\r\nextensions.add(TilemapPipe);\r\nextensions.add(GlTilemapAdaptor);\r\nextensions.add(GpuTilemapAdaptor);\r\n"],"names":["settings","Constant","i","b","o","a","t","_TilemapGeometry","Geometry","indexBuffer","buf","Buffer","BufferUsage","stride","__publicField","TilemapGeometry","TilemapAdaptor","UniformGroup","Matrix","TilemapPipe","renderer","adaptor","geom","size","totalIndices","len","createIndicesForQuads","_renderable","tilemap","instructionSet","batcher","_instructionSet","renderable","pipe_uniforms","u_proj_trans","u_global","anim_frame","u_anim_frame","ExtensionType","outBuffer","j","TileTextureArray","max_textures","tex","ind","tex_sizes","arr","count","null_color","bind_group_resources","bindIndex","texture","Texture","BindGroup","src","sampleValues","samplerSize","gl_tilemap_vertex","gl_tilemap_fragment","GlTilemapAdaptor","pipe","shader","tileset","tu","Shader","GlProgram","gpu_tilemap_vertex","gpu_tilemap_fragment","GpuTilemapAdaptor","GpuProgram","Q","Z","X","I","s","h","POINT_STRUCT","n","POINT_STRUCT_SIZE","Tilemap","Container","State","Bounds","v","res","textureOrArray","_a","_b","ts","TextureSource","flag","tileTexture","x","y","options","_c","_d","baseTexture","textureIndex","was_num","textureList","u","tileWidth","tileHeight","animX","animY","rotate","animCountX","animCountY","animDivisor","alpha","pb","offset","divisor","plugin","points","rects_count","vb","vertices","vertexBuf","vs","bk","ints","sz","textureId","w","animWidth","animHeight","animXEncoded","animYEncoded","u0","v0","u1","v1","u2","v2","u3","v3","w2","h2","cX","cY","groupD8","anim","bounds","_bounds","M","g","e","CompositeTilemap","tileTextures","texPerChild","len1","len2","children","childIndex","tileIndex","child","layers","extensions"],"mappings":"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"}